# Software Architecture Patterns & Approaches Guide

## Overview

This comprehensive guide covers three critical aspects of software architecture:

- **Deployment Architecture** (Where you put it?) → Monolith, Microservices, Serverless
- **Code Organization** (How you arrange it?) → Layered, Hexagonal, Clean
- **Domain Modeling** (How you think about business logic?) → DDD, Transaction Script, Active Record

---

## 1. Deployment Architecture Comparison

This document compares **Monolithic, Microservices, and Serverless Deployment Architectures** in detail.

| **Aspect**          | **Monolithic Architecture**                                                                                                                             | **Microservices Architecture**                                                                                                                                                                             | **Serverless Architecture**                                                                                                                                     |
| ------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Deployment Unit** | Single deployable unit (WAR, JAR, EXE, Docker image, etc.)                                                                                                    | Multiple independent services (each service has its own deployable unit/container)                                                                                                                               | Individual functions or event-driven handlers (e.g., AWS Lambda, Azure Functions)                                                                                     |
| **Where to Deploy** | Single application server / VM / container                                                                                                                    | Multiple containers, VMs, or Kubernetes pods                                                                                                                                                                     | Cloud provider’s serverless platform (AWS Lambda, Azure Functions, GCP Cloud Functions)                                                                              |
| **When to Use**     | - Small to medium apps `<br>` - Stable requirements `<br>` - Tight deadlines `<br>` - Teams are small (1–10 devs) `<br>` - Limited scalability needs | - Large/complex apps `<br>` - Frequent feature releases `<br>` - Teams are distributed by domain (feature teams) `<br>` - Scalability & fault isolation are critical                                       | - Event-driven workloads `<br>` - Sporadic traffic `<br>` - Lightweight micro-tasks `<br>` - No infra management preference `<br>` - Cost-sensitive workloads |
| **How to Deploy**   | - Package entire app and push to server/container `<br>` - Deploy all features together                                                                     | - Each service packaged as container/Docker image `<br>` - Deployed independently using Kubernetes, Docker Swarm, ECS, etc.                                                                                    | - Deploy function code directly to provider `<br>` - Provider manages scaling, infra, runtime environment                                                           |
| **Why (Pros)**      | - Simple deployment model `<br>` - Easy to test/debug `<br>` - Low infra complexity `<br>` - Best for MVPs/startups                                     | - Scalability per service `<br>` - Fault isolation (one service crash doesn’t kill app) `<br>` - Polyglot tech stack (each service can use different language/db) `<br>` - Faster independent deployments | - No server management `<br>` - Auto-scaling `<br>` - Pay-per-execution cost model `<br>` - Extremely fast to set up `<br>` - Ideal for spiky workloads       |
| **Why Not (Cons)**  | - Scaling = scale entire app `<br>` - Slow deployments `<br>` - Hard to maintain as app grows (tight coupling) `<br>` - Not flexible for large teams    | - High complexity (infra, networking, monitoring, CI/CD)`<br>` - Requires strong DevOps culture `<br>` - Higher cost if not optimized                                                                        | - Limited execution time/memory `<br>` - Cold start latency `<br>` - Vendor lock-in `<br>` - Not suitable for long-running processes                            |
| **Best Examples**   | Banking app prototype, ERP system, small e-commerce MVP                                                                                                       | Netflix, Amazon, Uber (large distributed systems)                                                                                                                                                                | Image processing function, IoT event processing, chatbot webhook, cron jobs                                                                                           |

### Key Takeaways

- **Monolith**: Simple, fast start, but limited scalability
- **Microservices**: Complex but great for large distributed teams and apps
- **Serverless**: Perfect for event-driven, pay-as-you-go workloads

---

## 2. Code Organization Architecture Comparison

This section compares three popular code organization patterns: **Layered Architecture**, **Hexagonal Architecture**, and **Clean Architecture**.

| Aspect                  | **Layered Architecture**                                                                                                                  | **Hexagonal Architecture (Ports & Adapters)**                                                                                                                                     | **Clean Architecture**                                                                                                                                                                                            |
| ----------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Definition**    | Organizes code into horizontal layers (Presentation → Business → Data). Each layer has a fixed responsibility and depends on the layer below. | Separates the application core from outside systems via ports (interfaces) and adapters (implementations). Focuses on isolating domain logic.                                           | A refinement of hexagonal, with concentric circles (Entities → Use Cases → Interfaces → Frameworks). Prioritizes domain independence and testability.                                                                |
| **Structure**     | Layers: UI → Application/Service → Domain/Business → Infrastructure/Data.                                                                    | Core Domain + Application Logic (inside)`<br>` Ports (interfaces) `<br>` Adapters (DB, UI, APIs).                                                                                   | Entities (core rules)`<br>` Use Cases (application-specific rules) `<br>` Interface Adapters (presenters, controllers, gateways) `<br>` Frameworks/Drivers (DB, UI, external).                                    |
| **Dependencies**  | Higher layers depend on lower ones (downward arrows).                                                                                           | Core depends on abstractions (ports), not implementations. Adapters depend on core.                                                                                                     | Strictly inward → outer layers depend on inner layers, never the reverse.                                                                                                                                              |
| **When to Use**   | - Simple business apps.`<br>` - CRUD-heavy systems. `<br>` - When team is small, codebase is manageable.                                    | - Systems that must handle multiple external interfaces (UI, DB, APIs).`<br>` - When domain logic must be isolated/testable. `<br>` - Useful for enterprise & long-living projects. | - Large, complex systems with evolving requirements.`<br>` - Mission-critical apps where independence from frameworks is important. `<br>` - When scalability, maintainability, and testability are top priorities. |
| **How to Apply**  | Separate code into projects/folders (e.g., Controllers → Services → Repositories → DB).                                                      | Define ports (interfaces) for DB, UI, external services.`<br>` Implement adapters (SQL, REST API, Console). `<br>` Plug them into the core.                                         | Place business rules in Entities/Use Cases.`<br>` Define interfaces in use cases. `<br>` Infrastructure & frameworks only implement these interfaces.                                                               |
| **Advantages**    | - Easy to understand.`<br>` - Good for small/medium projects. `<br>` - Works well with MVC frameworks.                                      | - Domain is isolated.`<br>` - Easy to swap DB, UI, or external systems. `<br>` - High testability (mock adapters).                                                                  | - Most flexible & framework-independent.`<br>` - Highly maintainable in the long run. `<br>` - Encourages SOLID principles.                                                                                         |
| **Disadvantages** | - Hard to swap infrastructure (tight coupling).`<br>` - Business logic often leaks into controllers/services. `<br>` - Poor testability.    | - More complex than layered.`<br>` - Extra boilerplate (ports/interfaces).                                                                                                            | - Most complex.`<br>` - Slower to implement. `<br>` - Overkill for small/medium apps.                                                                                                                               |
| **Best Fit**      | CRUD apps, admin panels, small internal tools.                                                                                                  | Enterprise apps with multiple delivery mechanisms (Web, CLI, APIs).                                                                                                                     | Banking systems, healthcare apps, large SaaS, high-maintenance systems.                                                                                                                                                 |
| **Example**       | A blogging app where controllers call services, which call repositories.                                                                        | A payment service with ports for DB & gateways, adapters for SQL/NoSQL & PayPal/Stripe.                                                                                                 | A hospital system with clean separation of patient rules (entities), treatment workflows (use cases), UI/API adapters, DB adapters.                                                                                     |

### Key Takeaways

- **Layered Architecture**: Good starting point for simple apps
- **Hexagonal Architecture**: Best when you want to isolate domain & make system pluggable
- **Clean Architecture**: Ideal for long-term, critical, large-scale apps where independence & maintainability are essential

---

## 3. Domain Modeling Approaches

This section compares three popular ways of structuring business logic in applications: **Domain-Driven Design (DDD)**, **Transaction Script**, and **Active Record**.

| Aspect                      | **Domain-Driven Design (DDD)**                                                                                                                                                                         | **Transaction Script**                                                                                                                                        | **Active Record**                                                                                                                                                                        |
| --------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Philosophy**        | Model the domain deeply, put business logic in rich domain objects that reflect real-world concepts.                                                                                                         | Organize code as simple procedures (scripts) that handle each transaction/request.                                                                                  | Combine data access (persistence) and business logic inside the same object (usually maps 1:1 with a DB table).                                                                                |
| **When to Use**       | - Complex domains with rich business rules.`<br>`- Many invariants, aggregates, policies, and long-term maintainability required.`<br>`- When language of business (ubiquitous language) is critical.    | - Simple applications with straightforward business rules.`<br>`- CRUD-like apps or batch-processing jobs.`<br>`- Small projects where speed > design purity.   | - Applications where domain logic is mostly CRUD + light validation.`<br>`- When mapping objects to DB tables is natural and sufficient.`<br>`- Popular in ORMs like Rails’ ActiveRecord. |
| **How It Works**      | - Entities, Value Objects, Aggregates, Repositories, Services.`<br>`- Emphasizes *ubiquitous language* and bounded contexts.`<br>`- Business logic lives inside domain models, persistence abstracted. | - Each user request mapped to a script (e.g.,`PlaceOrder`, `TransferMoney`).`<br>`- Logic is procedural and usually calls DB directly or through simple DAOs. | - Each class represents a table.`<br>`- Methods include both persistence (`save`, `delete`) and business logic (`calculateTax`, `applyDiscount`).                                    |
| **Code Structure**    | - Layers: Domain layer, Application layer, Infrastructure layer.`<br>`- Clear separation of concerns.`<br>`- Rich object model.                                                                          | - Thin layer of scripts/functions.`<br>`- Logic usually procedural, no deep object hierarchy.`<br>`- DB operations often embedded in scripts.                   | - Domain objects double as data mappers.`<br>`- Validation + persistence inside same class.`<br>`- Less layering.                                                                          |
| **Complexity**        | High — steep learning curve, but powerful for evolving domains.                                                                                                                                             | Low — easy to implement, very straightforward.                                                                                                                     | Medium — easier than DDD, but can become messy if business logic grows.                                                                                                                       |
| **Why Use It**        | - Long-term maintainability and scalability.`<br>`- Supports complex domains and evolving requirements.`<br>`- Good fit for microservices and bounded contexts.                                          | - Quick development.`<br>`- Best for apps with minimal logic (admin tools, CRUD systems).`<br>`- Easy for junior developers.                                    | - Simpler than DDD, more structured than Transaction Script.`<br>`- Popular in rapid app frameworks.`<br>`- Works well when domain matches database structure.                             |
| **Pros**              | - Expressive and aligned with business language.`<br>`- High maintainability.`<br>`- Encourages testability and decoupling.                                                                              | - Very fast to implement.`<br>`- Easy to read and reason about.`<br>`- Minimal overhead.                                                                        | - Simple mental model (object = table row).`<br>`- Quick dev with ORMs.`<br>`- Works well for simple CRUD + light business rules.                                                          |
| **Cons**              | - Overkill for simple domains.`<br>`- Requires strong team discipline.`<br>`- Initial complexity high.                                                                                                   | - Code duplication.`<br>`- Harder to maintain as domain grows.`<br>`- Business rules scattered across scripts.                                                  | - Tight coupling between DB schema and domain.`<br>`- Hard to manage complex business logic.`<br>`- Can violate SRP (mixes persistence + logic).                                           |
| **Example Use Cases** | - Banking systems (complex rules & invariants).`<br>`- E-commerce order management.`<br>`- Insurance, healthcare, ERP.                                                                                   | - Simple order entry system.`<br>`- Data import/export jobs.`<br>`- Small CRUD apps.                                                                            | - Blog/CMS.`<br>`- Small e-commerce app.`<br>`- Social media post management.                                                                                                              |

### Key Takeaways

- **Use DDD** if your domain is **complex, evolving, and business-critical**
- **Use Transaction Script** if your app is **simple, procedural, CRUD-heavy**
- **Use Active Record** if your app is **DB-driven with light business logic** and you want **fast productivity**

---

## Conclusion

Choosing the right architectural approach depends on your specific needs:

1. **Start simple** with monoliths and layered architecture for new projects
2. **Scale complexity** as your system and team grows (microservices, hexagonal/clean architecture)
3. **Match patterns** to your domain complexity (transaction script → active record → DDD)

Remember: Architecture decisions are trade-offs. Consider your team size, project timeline, maintainability requirements, and system complexity when making choices.
